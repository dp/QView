package org.myorg.gui.hypertree;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import javax.swing.JPanel;
import org.myorg.gui.*;
import org.myorg.gui.nbnode.RootNode;
import org.myorg.model.GuiAdapter;
import org.openide.ErrorManager;
import org.openide.util.NbBundle;
import org.openide.util.RequestProcessor;
import org.openide.util.Utilities;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;

/**
 * Top component which displays something.
 */
public class HTreeTopComponent extends TopComponent {    
    private static HTreeTopComponent instance;
    private static HashMap namedInstance = new HashMap();
//    private ObjectRepository repository = ObjectRepository.findInstance();
    private HTSimpleNode root = null; // the root of the tree
    private HyperTree hypertree = null; // the hypertree build
   
    /** path to the icon used by the component and its open action */
    static final String ICON_PATH = "org/myorg/gui/connection.gif";
    
    private static final String PREFERRED_ID = "HTreeTopComponent";
    private String instName;
    private HTView view;
    
    private HTreeTopComponent(String newName) {
        initComponents();
        this.instName = newName;
//        this.jLabel1.setText(newName);
        namedInstance.put(newName, this);
        setName(newName);      
        setToolTipText(NbBundle.getMessage(HTreeTopComponent.class, "HINT_HTreeTopComponent") + " : " + newName);
        setIcon(Utilities.loadImage(ICON_PATH, true));
        setBackground(java.awt.Color.white);
        setOpaque(true);
    }
    public JPanel getHypertreePanel() {
        return hypertreePanel;
    } //getHyperPanel
     public HyperTree getHypertree() {
        return hypertree;
    } //getHyperPanel
    public void setPanel(HTView vw){         
//        if (this.instName != RootNode.getTopName()){
            if (namedInstance.containsKey("MQ Environment")){
                ((HTreeTopComponent)namedInstance.remove("MQ Environment")).close();
            }
            view = vw;
            if (vw != null){            
                this.getHypertreePanel().removeAll();
                this.getHypertreePanel().add(view, BorderLayout.CENTER);
                view.setVisible(true);
                this.getHypertreePanel().setVisible(true);            
            }            
//        }       
    }
    // Method checks whether queues are to be shown in the tree      
    public boolean getQueuesCheck(){
         return this.jCheckQueues.isSelected();
    }
    public boolean getAllQueuesCheck(){
         return this.jCheckQueues1.isSelected();
    } 
    // Method sets queues are to be shown in the tree      
    public void setQueuesCheck(){
         this.jCheckQueues.setSelected(true);
    }
    
    // Method checks whether channels are to beshown in the tree   
    public boolean getChannelsCheck(){
        return this.jCheckChannels.isSelected();
    }
    public boolean getAllChannelsCheck(){
        return this.jCheckChannels1.isSelected();
    }
    
//    public boolean getSystemCheck(){
//        return this.jCheckSystem.isSelected();
//    }
    
    public String getSelectedNodeName(){
        String selectedNodeName = null;
//        System.out.println("-------------------------" + HyperView.findInstance(instName).getHyperTree().toString());
        if ((HyperView.findInstance(instName).getHyperTree() != null) && (HyperView.findInstance(instName).getHyperTree().getSelectedNode() != null)) { 
            selectedNodeName = ((HTSimpleNode)HyperView.findInstance(instName).getHyperTree().getSelectedNode()).getUniqueName();
            System.out.println("---------------------------------------------------" + selectedNodeName);
        }
        return selectedNodeName;
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        hypertreePanel = new javax.swing.JPanel();
        jCheckQueues = new javax.swing.JCheckBox();
        jCheckChannels = new javax.swing.JCheckBox();
        jCheckQueues1 = new javax.swing.JCheckBox();
        jCheckChannels1 = new javax.swing.JCheckBox();
        jToggleShowLables = new javax.swing.JToggleButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();

        setBackground(java.awt.Color.white);
        setForeground(java.awt.Color.black);
        setOpaque(true);
        hypertreePanel.setLayout(new java.awt.BorderLayout());

        hypertreePanel.setBackground(new java.awt.Color(255, 255, 255));
        hypertreePanel.setFont(new java.awt.Font("Tahoma", 0, 10));

        jCheckQueues.setSelected(true);
        org.openide.awt.Mnemonics.setLocalizedText(jCheckQueues, "Non-zero");
        jCheckQueues.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        jCheckQueues.setMargin(new java.awt.Insets(0, 0, 0, 0));
        jCheckQueues.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jCheckQueuesStateChanged(evt);
            }
        });
        jCheckQueues.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jCheckQueuesMouseClicked(evt);
            }
        });

        jCheckChannels.setSelected(true);
        org.openide.awt.Mnemonics.setLocalizedText(jCheckChannels, "Active");
        jCheckChannels.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        jCheckChannels.setMargin(new java.awt.Insets(0, 0, 0, 0));
        jCheckChannels.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jCheckChannelsStateChanged(evt);
            }
        });
        jCheckChannels.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jCheckChannelsMouseClicked(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jCheckQueues1, "All");
        jCheckQueues1.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        jCheckQueues1.setMargin(new java.awt.Insets(0, 0, 0, 0));
        jCheckQueues1.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jCheckQueues1StateChanged(evt);
            }
        });
        jCheckQueues1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jCheckQueues1MouseClicked(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jCheckChannels1, "All");
        jCheckChannels1.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        jCheckChannels1.setMargin(new java.awt.Insets(0, 0, 0, 0));
        jCheckChannels1.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jCheckChannels1StateChanged(evt);
            }
        });
        jCheckChannels1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jCheckChannels1MouseClicked(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jToggleShowLables, "Expand Lables");
        jToggleShowLables.setName("");
        jToggleShowLables.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jToggleShowLablesMouseClicked(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12));
        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, "Queues:");

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 12));
        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, "Channels:");

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jLabel1)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jCheckQueues)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jCheckQueues1)
                .add(30, 30, 30)
                .add(jLabel2)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jCheckChannels)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jCheckChannels1)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 229, Short.MAX_VALUE)
                .add(jToggleShowLables, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 114, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .add(hypertreePanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 711, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jToggleShowLables, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 17, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jLabel1)
                    .add(jCheckQueues, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 17, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jCheckQueues1)
                    .add(jLabel2)
                    .add(jCheckChannels, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 15, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jCheckChannels1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 15, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(hypertreePanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 362, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jToggleShowLablesMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jToggleShowLablesMouseClicked
        view.changeKleinMode(jToggleShowLables.isSelected());
    }//GEN-LAST:event_jToggleShowLablesMouseClicked

    private void jCheckChannels1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jCheckChannels1MouseClicked
        if (jCheckChannels1.isSelected() && !jCheckChannels.isSelected()){
            jCheckChannels.setSelected(true);
        }
        GuiAdapter.refreshNode(this.instName);
    }//GEN-LAST:event_jCheckChannels1MouseClicked

    private void jCheckChannels1StateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jCheckChannels1StateChanged
// TODO add your handling code here:
    }//GEN-LAST:event_jCheckChannels1StateChanged

    private void jCheckQueues1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jCheckQueues1MouseClicked
        if (jCheckQueues1.isSelected() && !jCheckQueues.isSelected()){
            jCheckQueues.setSelected(true);
        }
        GuiAdapter.refreshNode(this.instName);
    }//GEN-LAST:event_jCheckQueues1MouseClicked

    private void jCheckQueues1StateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jCheckQueues1StateChanged
// TODO add your handling code here:
    }//GEN-LAST:event_jCheckQueues1StateChanged

    private void jCheckQueuesMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jCheckQueuesMouseClicked
////	HyperTree tree = HyperView.findHyperView().getHyperTree();
////	HTSimpleNode oldNode = (HTSimpleNode)tree.getSelectedNode();
////        String nodeName = oldNode.getLongName();
//        HyperView.refreshNode(this.instName);
        if (jCheckChannels1.isSelected() && !jCheckChannels.isSelected()){
            jCheckChannels1.setSelected(false);
        }
        GuiAdapter.refreshNode(this.instName);
////        HTNode htNode = HyperView.findHyperView().getHTNode(nodeName);
////	tree.setSelectedNode(htNode);	
    }//GEN-LAST:event_jCheckQueuesMouseClicked

    private void jCheckChannelsMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jCheckChannelsMouseClicked
        if (jCheckQueues1.isSelected() && !jCheckQueues.isSelected()){
            jCheckQueues1.setSelected(false);
        }
        GuiAdapter.refreshNode(this.instName);

    }//GEN-LAST:event_jCheckChannelsMouseClicked

    private void jCheckChannelsStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jCheckChannelsStateChanged
//        HyperView.refreshNode();
    }//GEN-LAST:event_jCheckChannelsStateChanged

    private void jCheckQueuesStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jCheckQueuesStateChanged
//        HyperView.refreshNode();
    }//GEN-LAST:event_jCheckQueuesStateChanged
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel hypertreePanel;
    private javax.swing.JCheckBox jCheckChannels;
    private javax.swing.JCheckBox jCheckChannels1;
    private javax.swing.JCheckBox jCheckQueues;
    private javax.swing.JCheckBox jCheckQueues1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JToggleButton jToggleShowLables;
    // End of variables declaration//GEN-END:variables
    
    /**
     * Gets default instance. Do not use directly: reserved for *.settings files only,
     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
     * To obtain the singleton instance, use {@link findInstance}.
     */
    public static synchronized HTreeTopComponent getDefault(String networkName) {
        if (instance == null) {
            instance = new HTreeTopComponent(networkName);
        }
        return instance;
    }    
    public static synchronized HTreeTopComponent getDefault() {
        if (instance == null) {
            instance = new HTreeTopComponent(RootNode.getTopName());
        }
        return instance;
    }
    
    /**
     * Obtain the HTreeTopComponent instance. Never call {@link #getDefault} directly!
     */
    public static synchronized HTreeTopComponent findInstance() {
        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
        if (win == null) {
            ErrorManager.getDefault().log(ErrorManager.WARNING, "Cannot find HTree component. It will not be located properly in the window system.");
            return getDefault();
        }
        if (win instanceof HTreeTopComponent) {
            return (HTreeTopComponent)win;
        }
        ErrorManager.getDefault().log(ErrorManager.WARNING, "There seem to be multiple components with the '" + PREFERRED_ID + "' ID. That is a potential source of errors and unexpected behavior.");
        return getDefault();
    }
    public static HTreeTopComponent findInstance(String thisName){
        HTreeTopComponent httc = null;
        TopComponent win = (TopComponent) HTreeTopComponent.namedInstance.get(RootNode.getTopName());
        if (namedInstance.containsKey(thisName)){
            httc = (HTreeTopComponent) namedInstance.get(thisName);
        } else {            
            httc = new HTreeTopComponent(thisName);             
        }
//        win.close();              
        win = httc;
        win.open();
        win.requestActive();
        return httc;
    }
    
    public static void refreshAll(){        
        Iterator e = namedInstance.keySet().iterator();
        while (e.hasNext()){
            String instanceName = (String) e.next();
            refreshInstance(instanceName);
        }
    }    
    public static void refreshInstance(String instanceName){
        String selectedNodeName = findInstance(instanceName).getSelectedNodeName();
//        findInstance(instanceName).requestActive();
        // Build new node
        HyperView.refreshNode(instanceName);
        if (selectedNodeName != null){  // select node "selectedNodeName" if selectedNodeName has a value       
            System.out.println("selectedNode : " + selectedNodeName);
            HTNode selectedNode = HyperView.findInstance(instanceName).getHTNode(selectedNodeName);
            if (selectedNode != null){
                HyperView.findInstance(instanceName).getHyperTree().setSelectedNode(selectedNode);
            }            
        }
    }
    
    public int getPersistenceType() {
        return TopComponent.PERSISTENCE_ALWAYS;
    }
    
    public void componentOpened() {
        // TODO add custom code on component opening
    }
    
    public void componentClosed() {
        // TODO add custom code on component closing
    }
    
    /** replaces this in object stream */
    public Object writeReplace() {
        return new ResolvableHelper(this.instName);
    }
    
    protected String preferredID() {
        return PREFERRED_ID;
    }
    
    final static class ResolvableHelper implements Serializable {
        private static final long serialVersionUID = 1L;
        private static String networkName = RootNode.getTopName();
        public ResolvableHelper(String nwName){
            networkName = nwName;
        }
        public Object readResolve() {
            return HTreeTopComponent.getDefault(networkName);
        }
    }  
    
}
